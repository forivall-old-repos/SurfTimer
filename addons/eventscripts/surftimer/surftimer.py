# Surf Timer version 1.0.3 by Steven Hartin (freddukes)
# ./addons/eventscripts/surftimer/surftimer.py
# Unofficial Modification

#################################
#### DO NOT EDIT THIS FILE, #####
####    IF YOU DO, THINGS   #####
####       COULD BREAK      #####
#################################

# Import Modules
import es
import popuplib
import playerlib
import langlib
import gamethread
import math
import vecmath
import services
import effectlib
import cfglib

import cPickle
import os
import time
import datetime
from operator import itemgetter

# psyco, more unstable but a lot faster
import psyco
psyco.full()

# Globals
started	    = []
effects     = []
mapDicts    = {}
players     = {}
target      = {}
playerList  = None
stageMenu   = None
bonusMenu   = None
currentMap  = es.ServerVar('eventscripts_currentmap')

info = es.AddonInfo()
info.author      = "Steven Hartin (freddukes)"
info.name        = "Surf Timer"
info.basename    = "surftimer"
info.version     = "1.0.3"
info.url         = "http://addons.eventscripts.com/addons/view/%s"%info.basename
info.description = "Time how long to surf through a map" 

es.ServerVar(info.basename, info.version, info.description + " made by " + info.author).makepublic()

text = lambda identifier, options = {}, lang = "en" : "No strings.ini found in ../addons/eventscripts/%(basename)s/%(basename)s.py" % {"basename" : info.basename}

""" Load the dictionary """
dictPath = os.path.join( es.getAddonPath( info.basename ), "data.db" )
if os.path.isfile(dictPath):
	fileStream = open(dictPath, 'r')
	mapDicts   = cPickle.load(fileStream)
	fileStream.close()
	
""" Load the languages """
langPath = os.path.join( es.getAddonPath( info.basename ), "strings.ini" )
if os.path.isfile(langPath):
	text = langlib.Strings(langPath)
	
""" Set up an auth check service, to return whether or not the user is authed. """
if services.isRegistered('auth'):
	auth_service = services.use('auth')
	auth_service.registerCapability('surftimer', auth_service.ADMIN)
	isAuthed = lambda x: auth_service.isUseridAuthorized(x, 'surftimer')
else:
	isAuthed = lambda x: False
	
def load():
	""" If the script is loaded halfway through a load, ensure the delays start """
	if str(currentMap):
		es_map_start({'mapname':str(currentMap)})
	es.regsaycmd('!restart', 'surftimer/restart', 'Teleport back to start')
		
def unload():
	del started[:]
	players.clear()
	fileStream = open(dictPath, 'w')
	cPickle.dump(mapDicts, fileStream)
	fileStream.close()
	gamethread.cancelDelayed('surftime_checkloop')
	gamethread.cancelDelayed('surftimer_hudloop')
	if playerList:
		playerList.delete()
	
def round_end(event_var):
	es_map_start({"mapname":str(currentMap)})
	
def es_map_start(event_var):
	""" Clear the lists """
	del started[:]
	players.clear()
	""" Save the database """
	fileStream = open(dictPath, 'w')
	cPickle.dump(mapDicts, fileStream)
	fileStream.close()
	""" Restart the timer if there isn't a timer already """
	gamethread.cancelDelayed('surftime_checkloop')
	gamethread.cancelDelayed('surftimer_hudloop')
	if event_var['mapname'] in mapDicts:
		if "endpos" not in mapDicts[event_var['mapname']]:
			return
		if "startpos" not in mapDicts[event_var['mapname']]:
			return
		gamethread.delayedname(0.1, 'surftime_checkloop', checkLoop)
		hudLoop()
	
def player_disconnect(event_var):
	""" If a player disconnects early, clear up the delay list. """
	userid = int(event_var['userid'])
	if userid in started:
		started.remove(userid)
	if userid in players:
		del players[userid]

def player_death(event_var):
	""" Remove players when they die. """
	userid = int(event_var["userid"])
	if userid in started:
		started.remove(userid)
	if userid in players:
		del players[userid]

def player_say(event_var):
	""" Executed when a player talks. Run the chat commands """
	message = event_var['text'].strip()
	userid  = int(event_var['userid'])
	if message == "!surftimer":
		""" Admin menu """
		if isAuthed(userid):
			adminPopup.send(userid)
	
	elif message.startswith("!wr"):
		"""
		Display world record time to all players
		"""
		sortedList = mk_sortDict(str(currentMap))
		es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreen%s holds the world record with time #default%s#lightgreen." % (mapDicts[str(currentMap)][sortedList[0][0]]["name"], formatTime(sortedList[0][1])))

	elif message.startswith("!top"):
		""" 
		Display a popup with all times for that map, or if a map
		was present as an argument, display for that map.
		
		!top // display current map records
		!top <map name> // displays <map name>'s current records 
		"""
		if message.count(" "):
			mapName = " ".join(message.split()[1:])
		else:
			mapName = str(currentMap)
		if mapName not in mapDicts:
			es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreenSorry, we cannot find %s on the server." % mapName)
			return
		if "startpos" not in mapDicts[mapName]: return
		if "endpos" not in mapDicts[mapName]: return
		topMenu = popuplib.easymenu("topMenu%s" % userid, "_popup_choice",None)
		topMenu.settitle("[Map Records : %s]" % mapName)
		sortedList = mk_sortDict(mapName)
		if sortedList:
			lx = 1
			for top in sortedList:
				topMenu.addoption('an', "Rank " + str(lx) + ": " + mapDicts[mapName][top[0]]["name"] + " " + formatTime(mapDicts[mapName][top[0]]["time"]))
				lx += 1
		else:
			topMenu.addoption('an', "[No places recorded]")
		topMenu.send(userid)

	elif message.startswith("!pr"):
		""" 
		Similar to a rank command. Tell the user their time or another person's
		time on that current map.
		
		!pr // displays their time for that map
		!pr <userid/name/steamid> // displays the user's time for that map
		
		TODO: Add in an additional [map] argument and test for the last argument
			and see if it's a dict item. If so, then they want information for
			that map.
		"""
		mapName = str(currentMap)
		if mapName not in mapDicts: return
		if "startpos" not in mapDicts[mapName]: return
		if "endpos" not in mapDicts[mapName]: return
		if message.count(" "):
			message = " ".join(message.split()[1:])
			target  = es.getuserid(message)
		else:
			target  = userid
		if not target:
			es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreenSorry, we cannot find %s on the server." % message)
			return
		steamid = es.getplayersteamid(target)
		(_pos, _len) = mk_sortDictIndex(mapName, steamid)
		for player in es.getUseridList():
			if (_pos > 0):
				sortedList = mk_sortDict(str(currentMap))
				dictObject = mapDicts[mapName][steamid]
				es.tell(player, "#multi", "#green[Surf Timer] #default- #lightgreen%s is ranked #default%s/%s #lightgreenwith time #default%s #lightgreen(#default+%s#lightgreen)." % (dictObject['name'], _pos, _len, formatTime(dictObject['time']), formatTime(dictObject['time'] - sortedList[0][1])))
			else:
				es.tell(player, "#multi", "#green[Surf Timer] #default- #lightgreen%s has not yet completed this map." % es.getplayername(target))

	elif message.startswith("!stage"):
		"""
		Opens a stage selection menu
		"""
		mapName = str(currentMap)
		global stageMenu
		stageMenu = popuplib.easymenu('stageMenu', '_popup_choice', stageMenu_select)
		stageMenu.settitle("[Stage Menu : %s]" % (mapName))
		entities = es.createentitylist('info_teleport_destination')
		""" Create Stage Menu """
		stages = 0
		for a in range(1,26):
			for b in entities:
				if (es.entitygetvalue(b, 'targetname') == "timer_stage%s" % a):
					stageMenu.addoption('%s' % a, "Stage %s" % a)
					stages += 1
		if (stages > 1):
			stageMenu.send(userid)
			if (userid in started):
				es.tell(userid, "#green", "Teleporting to a stage while the timer is active will clear your time")
		else:
			es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreenThis is not a staged map.")

	elif message.startswith("!bonus"):
		"""
		Opens a bonus selection menu
		"""
		mapName = str(currentMap)
		global bonusMenu
		bonusMenu = popuplib.easymenu('bonusMenu', '_popup_choice', bonusMenu_select)
		bonusMenu.settitle("[Bonus Menu : %s]" % (mapName))
		entities = es.createentitylist('info_teleport_destination')
		bonuses = 0
		""" Set up bonus menu and count the number of bonuses (up to 3 bonuses) """
		for a in range(1,4):
			for b in entities:
				if (es.entitygetvalue(b, 'targetname') == "timer_bonus%s" % a):
					bonuses += 1
					bonusMenu.addoption('%s' % a, "Bonus %s" % a)
		if (bonuses > 1):
			bonusMenu.send(userid)
		elif (bonuses == 1):
			entities = es.createentitylist('info_teleport_destination')
			for i in entities:
				if (es.entitygetvalue(i, 'targetname') == "timer_bonus1"):
					x = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[0]") * -1 / 2
					y = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[1]") * -1 / 2
					z = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[2]") * -1 / 2
					es.setplayerprop(userid, "CBasePlayer.localdata.m_vecBaseVelocity", es.createvectorstring(x, y, z))
					gamethread.delayed(0.01, es.setplayerprop, (userid, "CBasePlayer.localdata.m_vecBaseVelocity", es.createvectorstring(x, y, z)))
					startPos = es.entitygetvalue(i, 'origin').split(' ')
					startAng = es.entitygetvalue(i, 'angles').split(' ')
					es.setpos(userid, startPos[0], startPos[1], startPos[2])
					es.setang(userid, startAng[0], startAng[1], startAng[2])
		else:
			es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreenCurrent map has no bonuses.")

def stageMenu_select(userid, choice, popupid):
	if (es.getplayerteam(userid) == 1): return
	if (userid in started):
		started.remove(userid)
	for a in range(1,26):
		if (choice == '%s' % a):
			entities = es.createentitylist('info_teleport_destination')
			for b in entities:
				if (es.entitygetvalue(b, 'targetname') == "timer_stage%s" % a):
					x = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[0]") * -1 / 2
					y = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[1]") * -1 / 2
					z = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[2]") * -1 / 2
					es.setplayerprop(userid, "CBasePlayer.localdata.m_vecBaseVelocity", es.createvectorstring(x, y, z))
					gamethread.delayed(0.01, es.setplayerprop, (userid, "CBasePlayer.localdata.m_vecBaseVelocity", es.createvectorstring(x, y, z)))
					startPos = es.entitygetvalue(b, 'origin').split(' ')
					startAng = es.entitygetvalue(b, 'angles').split(' ')
					es.setpos(userid, startPos[0], startPos[1], startPos[2])
					es.setang(userid, startAng[0], startAng[1], startAng[2])
	if (int(choice) > 7):
		gamethread.delayed(0.5, stageMenu.sendPage, (userid, (math.ceil(float(choice) / float(7)))))
	else:
		gamethread.delayed(0.5, stageMenu.send, (userid))

def bonusMenu_select(userid, choice, popupid):
	if (es.getplayerteam(userid) == 1): return
	for a in range(1,4):
		if (choice == '%s' % a):
			entities = es.createentitylist('info_teleport_destination')
			for b in entities:
				if (es.entitygetvalue(b, 'targetname') == "timer_bonus%s" % a):
					x = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[0]") * -1 / 2
					y = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[1]") * -1 / 2
					z = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[2]") * -1 / 2
					es.setplayerprop(userid, "CBasePlayer.localdata.m_vecBaseVelocity", es.createvectorstring(x, y, z))
					gamethread.delayed(0.01, es.setplayerprop, (userid, "CBasePlayer.localdata.m_vecBaseVelocity", es.createvectorstring(x, y, z)))
					startPos = es.entitygetvalue(b, 'origin').split(' ')
					startAng = es.entitygetvalue(b, 'angles').split(' ')
					es.setpos(userid, startPos[0], startPos[1], startPos[2])
					es.setang(userid, startAng[0], startAng[1], startAng[2])

def restart():
	""" Teleports player to first level """
	userid = es.getcmduserid()
	if (es.getplayerteam(userid) != 1):
		entities = es.createentitylist('info_teleport_destination')
		for i in entities:
			if (es.entitygetvalue(i, 'targetname') == "timer_stage1"):
				x = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[0]") * -1 / 2
				y = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[1]") * -1 / 2
				z = es.getplayerprop(userid, "CBasePlayer.localdata.m_vecVelocity[2]") * -1 / 2
				es.setplayerprop(userid, "CBasePlayer.localdata.m_vecBaseVelocity", es.createvectorstring(x, y, z))
				gamethread.delayed(0.01, es.setplayerprop, (userid, "CBasePlayer.localdata.m_vecBaseVelocity", es.createvectorstring(x, y, z)))
				startPos = es.entitygetvalue(i, 'origin').split(' ')
				startAng = es.entitygetvalue(i, 'angles').split(' ')
				gamethread.delayed(0.01, es.setpos, (userid, startPos[0], startPos[1], startPos[2]))
				es.setang(userid, startAng[0], startAng[1], startAng[2])

def mk_sortDict(map_name):
	""" Sort steamid's by time taken. Returns sorted dict of steamid:time """
	rsort = {}
	for i in mapDicts[map_name].keys():
		if (str(i) != "startpos" and str(i) != "endpos"):
			rsort[i] = mapDicts[map_name][i]["time"]
	return sorted(rsort.items(), key=itemgetter(1))

def mk_sortDictIndex(map_name, steamid):
	""" Sorts steamid's and returns position and size of sorted list ($rank and $totalrank) """
	rsort = {}
	found_sid = 0
	for k in mapDicts[map_name].keys():
		if (not str(k) == "startpos") and (not str(k) == "endpos"):
			rsort[k] = mapDicts[map_name][k]["time"]
			if (str(k) == steamid):
				found_sid = 1
	if (found_sid == 0):
		return 0, 0
	sortedList = sorted(rsort.items(), key=itemgetter(1))
	lx = 1
	for top in sortedList:
		if (str(top[0]) == steamid):
			return lx, (len(mapDicts[map_name].keys()) - 2)
		lx += 1
	return 0, 0
			
def hudLoop():
	""" Constantly loop the HUD for players telling them their current time spent surfing """
	for userid1 in es.getUseridList():
		if userid1 not in started: continue
		if userid1 not in players: continue
		timeLeft = formatTime2(time.time() - players[userid1][0])
		es.usermsg('create', 'surftimer', 'HintText')
		es.usermsg('write',  'string',    'surftimer', 'Time: %s' % timeLeft)
		es.usermsg('send',   'surftimer', userid1)
		"""for userid2 in es.getUseridList():
			if (es.getplayerteam(userid2) != 1): continue
			if (es.getplayerprop(userid2, 'CBasePlayer.m_iObserverMode') != 4 and es.getplayerprop(userid2, "CBasePlayer.m_iObserverMode") != 5): continue
			if (es.getuserid(es.getplayerprop(userid2, 'CBasePlayer.m_hObserverTarget')) ==  userid1):
				es.usermsg('send',   'surftimer', userid2)"""
		es.usermsg('delete', 'surftimer')
	gamethread.delayedname(1, 'surftimer_hudloop', hudLoop)
			
def checkLoop():
	""" Iterate through a list of all the players and check their location """
	try:
		for player in es.getUseridList():
			if (player in started) and (int(es.getplayerteam(player)) > 1):
				lowerVertex, upperVertex = mapDicts[str(currentMap)]["endpos"]
				timeTaken = time.time() - players[player][0]
				if vecmath.isbetweenRect(es.getplayerlocation(player), lowerVertex, upperVertex):
					""" Player has finished... """
					""" Add their time to the dictionary which will save """
					""" Tell all users that he finished and append his ID to the finished list """
					steamid = es.getplayersteamid(player)
					sortedList = mk_sortDict(str(currentMap))
					""" Check if the player is in first place """
					if sortedList:
						if (timeTaken < sortedList[0][1]):
							if steamid not in mapDicts[str(currentMap)]:
								mapDicts[str(currentMap)][steamid] = {'time':timeTaken, 'name':es.getplayername(player)}
								(_pos, _len) = mk_sortDictIndex(str(currentMap), es.getplayersteamid(player))
								for userid in es.getUseridList():
									es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreen%s has finished in #default%s #lightgreen(#default-%s#lightgreen) with rank #default%s/%s#lightgreen." % (es.getplayername(player), formatTime(timeTaken), formatTime(sortedList[0][1] - timeTaken), _pos, _len))
									es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreen%s has broken the world record!" % es.getplayername(player))
							else:
								temp = mapDicts[str(currentMap)][steamid]['time']
								mapDicts[str(currentMap)][steamid]['time']  = timeTaken
								(_pos, _len) = mk_sortDictIndex(str(currentMap), es.getplayersteamid(player))
								for userid in es.getUseridList():
									es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreen%s has finished in #default%s #lightgreen(#default-%s#lightgreen) with rank #default%s/%s#lightgreen, improving by #default%s#lightgreen." % (es.getplayername(player), formatTime(timeTaken), formatTime(sortedList[0][1] - timeTaken), _pos, _len, formatTime(temp - timeTaken)))
									es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreen%s has broken the world record!" % es.getplayername(player))
							for userid in es.getUseridList():
								es.playsound(userid, "ui/vote_started.wav", 1.0)
								gamethread.delayed(1.5, es.playsound, (userid, "vo/announcer_am_killstreak02.wav", 1.0))
						else:
							if steamid not in mapDicts[str(currentMap)]:
								mapDicts[str(currentMap)][steamid] = {'time':timeTaken, 'name':es.getplayername(player)}
								(_pos, _len) = mk_sortDictIndex(str(currentMap), es.getplayersteamid(player))
								for userid in es.getUseridList():
									es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreen%s has finished in #default%s #lightgreen(#default+%s#lightgreen) with rank #default%s/%s#lightgreen." % (es.getplayername(player), formatTime(timeTaken), formatTime(timeTaken - sortedList[0][1]), _pos, _len))
							else:
								if (mapDicts[str(currentMap)][steamid]['time'] > timeTaken):
									temp = mapDicts[str(currentMap)][steamid]['time']
									mapDicts[str(currentMap)][steamid]['time']  = timeTaken
									(_pos, _len) = mk_sortDictIndex(str(currentMap), es.getplayersteamid(player))
									for userid in es.getUseridList():
										es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreen%s has finished in #default%s #lightgreen(#default+%s#lightgreen) with rank #default%s/%s#lightgreen, improving by #default%s#lightgreen." % (es.getplayername(player), formatTime(timeTaken), formatTime(timeTaken - sortedList[0][1]), _pos, _len, formatTime(temp - timeTaken)))
								else:
									(_pos, _len) = mk_sortDictIndex(str(currentMap), es.getplayersteamid(player))
									for userid in es.getUseridList():
										es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreen%s has finished in #default%s #lightgreen(#default+%s#lightgreen)." % (es.getplayername(player), formatTime(timeTaken), formatTime(timeTaken - sortedList[0][1])))
							for userid in es.getUseridList():
								es.playsound(userid, "ui/scored.wav", 0.5)
					#Else block below contributed by Lange for SurfiT
					else:
						if steamid not in mapDicts[str(currentMap)]:
							mapDicts[str(currentMap)][steamid] = {'time':timeTaken, 'name':es.getplayername(player)}
							(_pos, _len) = mk_sortDictIndex(str(currentMap), es.getplayersteamid(player))
							for userid in es.getUseridList():
								es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreen%s has finished in #default%s with rank #default%s/%s#lightgreen." % (es.getplayername(player), formatTime(timeTaken), _pos, _len))
						else:
							if (mapDicts[str(currentMap)][steamid]['time'] > timeTaken):
								temp = mapDicts[str(currentMap)][steamid]['time']
								mapDicts[str(currentMap)][steamid]['time']  = timeTaken
								(_pos, _len) = mk_sortDictIndex(str(currentMap), es.getplayersteamid(player))
								for userid in es.getUseridList():
									es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreen%s has finished in #default%s with rank #default%s/%s#lightgreen, improving by #default%s#lightgreen." % (es.getplayername(player), formatTime(timeTaken), _pos, _len, formatTime(temp - timeTaken)))
							else:
								(_pos, _len) = mk_sortDictIndex(str(currentMap), es.getplayersteamid(player))
								for userid in es.getUseridList():
									es.tell(userid, "#multi", "#green[Surf Timer] #default- #lightgreen%s has finished in #default%s#lightgreen." % (es.getplayername(player), formatTime(timeTaken)))
						for userid in es.getUseridList():
							es.playsound(userid, "ui/scored.wav", 0.5)
						
					started.remove(player)
					#End Lange modifications
				else:
					lowerVertex, upperVertex = mapDicts[str(currentMap)]["startpos"]
					if vecmath.isbetweenRect(es.getplayerlocation(player), lowerVertex, upperVertex):
						players[player] = [time.time(), 0]
			elif (int(es.getplayerteam(player)) > 1):
				c_player = playerlib.getPlayer(player)
				if (c_player.attributes["isdead"] == 0):
					lowerVertex, upperVertex = mapDicts[str(currentMap)]["startpos"]
					if vecmath.isbetweenRect(es.getplayerlocation(player), lowerVertex, upperVertex):
						""" Player has started """
						tokens = {}
						tokens['name'] = es.getplayername(player)
						tell(player, "started", tokens)
						started.append(player)
						players[player] = [time.time(), 0]
		gamethread.delayedname(0.1, 'surftime_checkloop', checkLoop)
	except KeyError:
		pass
			
def tell(userid, message, options = {}, tellMessage = True):
	""" Just a simple wrapper to send a multi language text or return it if tellMessage is False """
	message = text(message, options, playerlib.getPlayer(userid).get("lang") )
	if tellMessage:
		es.tell(userid, '#multi', '#green[Surf Timer] #default- #lightgreen%s' % message)
	else:
		return message

def formatTime(time):
	mins = int(time / 60)
	if (mins < 10):
		mins = "0" + str(mins)
	secs = int(time % 60)
	if (secs < 10):
		secs = "0" + str(secs)
	msecs = (str(time).split(".")[-1])[:2]
	if (msecs < 10):
		msecs = "0" + str(msecs)
	return ("%s:%s.%s" % (mins, secs, msecs))

def formatTime2(time):
	mins = int(time / 60)
	if (mins < 10):
		mins = "0" + str(mins)
	secs = int(time % 60)
	if (secs < 10):
		secs = "0" + str(secs)
	return ("%s:%s" % (mins, secs))
	
def effectLoop(userid, start, red = 0, green = 255, blue = 0):
	""" A method to loop the effects """
	effectlib.drawBox(start, es.getplayerlocation(userid), red=red, green=green, blue=blue, seconds=0.1)
	gamethread.delayedname(0.1, 'surftimer_effects', effectLoop, (userid, start, red, green, blue) )
	
def adminPopupMenuselect(userid, choice, popupid):
	"""
	Handles the menu select from the admin menu.
	
	Note: You have to staticly cast the getplayerlocation to a list so we can
		edit the items in it as getplayerlocation returns a tuple which can't
		be edited. 
	"""
	mapName = str(currentMap)
	if choice == 1:
		if mapName not in mapDicts:
			mapDicts[mapName] = {}
		if "startpos" not in mapDicts[mapName]:
			mapDicts[mapName]['startpos'] = [ (0,0,0), (0,0,0) ]
		if userid not in effects:
			effects.append(userid)
			tell(userid, 'added start one')
			start = list(es.getplayerlocation(userid))
			start[2] -= 5
			mapDicts[mapName]["startpos"][0] = start
			effectLoop(userid, start)
		else:
			effects.remove(userid)
			gamethread.cancelDelayed('surftimer_effects')
			tell(userid, 'added start two')
			mapDicts[mapName]["startpos"][1] = list(es.getplayerlocation(userid))
			mapDicts[mapName]["startpos"][1][2] -= 5
			if "endpos" in mapDicts[mapName]:
				gamethread.delayedname(0.1, 'surftime_checkloop', checkLoop)
				hudLoop()
		adminPopup.send(userid)
			
	elif choice == 2:
		if mapName not in mapDicts:
			mapDicts[mapName] = {}
		if "endpos" not in mapDicts[mapName]:
			mapDicts[mapName]['endpos'] = [ (0,0,0), (0,0,0) ]
		if userid not in effects:
			effects.append(userid)
			tell(userid, 'added end one')
			start = list(es.getplayerlocation(userid))
			start[2] -= 5
			mapDicts[mapName]["endpos"][0] = start
			effectLoop(userid, start, 255, 0)
		else:
			effects.remove(userid)
			gamethread.cancelDelayed('surftimer_effects')
			tell(userid, 'added end two')
			mapDicts[mapName]["endpos"][1] = list(es.getplayerlocation(userid))
			mapDicts[mapName]["endpos"][1][2] -= 5
			if "startpos" in mapDicts[mapName]:
				gamethread.delayedname(0.1, 'surftime_checkloop', checkLoop)
				hudLoop()
		adminPopup.send(userid)
			
	elif choice == 3:
		if mapName in mapDicts:
			del mapDicts[mapName]
			gamethread.cancelDelayed('surftime_checkloop')
		tell(userid, 'delete')
		
	elif choice == 4:
		if mapName in mapDicts:
			popuplib.close("surftimer_admin", userid)
			global playerList
			playerList = popuplib.easymenu("surftimer_playerlist", None, playerPopupMenuselect)
			playerList.settitle("[Surf Timer DB : %s]" % mapName)
			sortedList = mk_sortDict(mapName)
			if sortedList:
				lx = 1
				for top in sortedList:
					playerList.addoption('%s' % str(top[0]), "Rank " + str(lx) + ": " + mapDicts[mapName][top[0]]["name"] + " " + formatTime(mapDicts[mapName][top[0]]["time"]))
					lx += 1
			else:
				playerList.setdescription("[No places recorded]")
			playerList.send(userid)
		else:
			tell(userid, 'no map records', {})

def playerPopupMenuselect(userid, choice, popupid):
	mapName = str(currentMap)
	if mapDicts[mapName]:
		if mapDicts[mapName][str(choice)]:
			tokens = {}
			tokens['steamid'] = str(choice)
			tokens['name'] = mapDicts[mapName][str(choice)]["name"]
			del mapDicts[mapName][str(choice)]
			tell(userid, 'remove player', tokens)
			if playerList:
				playerList.send(userid)
		else:
			if "STEAM" in str(choice):
				tell(userid, 'failed remove player', {})
				if playerList:
					playerList.send(userid)
	else:
		tell(userid, 'no map records', {})
					
adminPopup = popuplib.create("surftimer_admin")
adminPopup.addline("Surf Timer Admin")
adminPopup.addline("-" * 30)
adminPopup.addline("->1. Add/Move the start position")
adminPopup.addline("->2. Add/Move the finish position")
adminPopup.addline("->3. Delete map positions and times")
adminPopup.addline("->4. Delete single record from map")
adminPopup.addline("-" * 30)
adminPopup.addline("0. Close")
adminPopup.menuselectfb = adminPopupMenuselect
